/*
 * ==========================================================================
 * !! IMPORTANT: SUPABASE SETUP INSTRUCTIONS !!
 * ==========================================================================
 * * Before this server will work, you MUST set up your Supabase database.
 * * 1. Create a new project in Supabase.
 * 2. Go to the "SQL Editor" section (the one with the `>` icon).
 * 3. Click "New query" and paste ALL of the code below and click "RUN".
 *
 * ------------------- PASTE THIS IN SUPABASE SQL EDITOR --------------------
 *
 * -- Create the 'posts' table
 * CREATE TABLE public.posts (
 * id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 * created_at TIMESTAMPTZ DEFAULT now(),
 * title TEXT NOT NULL,
 * category TEXT,
 * tags TEXT[],
 * image TEXT,
 * excerpt TEXT,
 * "fullContent" TEXT,
 * published BOOLEAN DEFAULT false,
 * date TEXT
 * );
 * * -- Create the 'categories' table
 * CREATE TABLE public.categories (
 * id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 * created_at TIMESTAMPTZ DEFAULT now(),
 * name TEXT NOT NULL UNIQUE,
 * tags TEXT[] DEFAULT ARRAY[]::TEXT[]
 * );
 *
 * -- Create the 'comments' table WITH moderation
 * CREATE TABLE public.comments (
 * id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 * created_at TIMESTAMPTZ DEFAULT now(),
 * post_id BIGINT NOT NULL,
 * name TEXT NOT NULL,
 * content TEXT NOT NULL,
 * is_approved BOOLEAN DEFAULT false,
 * CONSTRAINT comments_post_id_fkey FOREIGN KEY (post_id)
 * REFERENCES public.posts (id) ON DELETE CASCADE
 * );
 *
 * * -- Create a helper function to remove an item from a text array
 * CREATE OR REPLACE FUNCTION array_remove(arr TEXT[], item TEXT)
 * RETURNS TEXT[] AS $$
 * BEGIN
 * RETURN array_agg(elem) FROM unnest(arr) AS elem WHERE elem <> item;
 * END;
 * $$ LANGUAGE plpgsql;
 * * -- Create a helper function to replace an item in a text array
 * CREATE OR REPLACE FUNCTION array_replace(arr TEXT[], old_item TEXT, new_item TEXT)
 * RETURNS TEXT[] AS $$
 * DECLARE
 * new_arr TEXT[];
 * BEGIN
 * SELECT array_agg(CASE WHEN elem = old_item THEN new_item ELSE elem END)
 * INTO new_arr
 * FROM unnest(arr) AS elem;
 * RETURN new_arr;
 * END;
 * $$ LANGUAGE plpgsql;
 *
 * -- Enable Row Level Security (RLS) for all tables
 * ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
 * ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;
 * ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;
 *
 * -- Create policies for 'posts' and 'categories'
 * CREATE POLICY "Public tables are viewable by everyone" 
 * ON public.posts FOR SELECT USING (true);
 * CREATE POLICY "Public categories are viewable by everyone" 
 * ON public.categories FOR SELECT USING (true);
 *
 * -- Create policies for 'comments'
 * CREATE POLICY "Public can only see approved comments"
 * ON public.comments FOR SELECT
 * USING (is_approved = true);
 *
 * CREATE POLICY "Anyone can create comments"
 * ON public.comments
 * FOR INSERT
 * TO anon -- This explicitly names the public (anonymous) role
 * WITH CHECK (true);
 * * * ------------------------- END OF SQL CODE --------------------------------
 *
 * 4. Go to "Project Settings" (the gear icon).
 * 5. Go to "API".
 * 6. Find the "Project URL" and "Project API Keys" (the `anon` `public` key).
 * 7. You will add these to your environment variables (e.g., in a `.env` file
 * or in your hosting provider's settings) along with your other secrets.
 * * SUPABASE_URL="YOUR_PROJECT_URL"
 * SUPABASE_ANON_KEY="YOUR_ANON_KEY"
 * ADMIN_USER="admin"
 * ADMIN_PASS="password123"
 * SESSION_SECRET="your-very-secret-key-change-this"
 * * ==========================================================================
 */

const express = require('express');
const path = require('path');
const cors = require('cors'); 
const session = require('express-session');
const { createClient } = require('@supabase/supabase-js');

// --- Load Environment Variables (for local development) ---
if (process.env.NODE_ENV !== 'production') {
    require('dotenv').config({ path: path.join(__dirname, '.env') });
}

const app = express();
// Render provides the PORT environment variable
const PORT = process.env.PORT || 3000;

// --- SUPABASE & ADMIN CREDENTIALS ---
const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY;
const ADMIN_USER = process.env.ADMIN_USER;
const ADMIN_PASS = process.env.ADMIN_PASS;
const SESSION_SECRET = process.env.SESSION_SECRET;

// Check if all required env vars are set
if (!SUPABASE_URL || !SUPABASE_ANON_KEY || !ADMIN_USER || !ADMIN_PASS || !SESSION_SECRET) {
    console.error('FATAL ERROR: Missing required environment variables.');
    console.log('Please check your .env file or hosting environment.');
    process.exit(1);
}

// --- Initialize Supabase Client ---
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// --- Middleware ---
app.use(cors()); 
app.use(express.json({ limit: '10mb' })); 
app.use(express.urlencoded({ extended: true }));

// --- Session Middleware ---
app.use(session({
    secret: SESSION_SECRET,
    resave: false,
    saveUninitialized: true,
    cookie: { 
        maxAge: 1000 * 60 * 60 * 24 // 1 day
        // secure: process.env.NODE_ENV === 'production' // Enable this if you are using HTTPS
    }
}));


// --- Helper Function to format categories ---
function formatCategories(categoryList) {
    if (!categoryList) return {};
    return categoryList.reduce((acc, cat) => {
        acc[cat.name] = cat.tags || [];
        return acc;
    }, {});
}

// --- Authentication Middleware ---
function checkAuth(req, res, next) {
    if (req.session.isLoggedIn) {
        next();
    } else {
        res.redirect('/admin/login.html');
    }
}

function checkApiAuth(req, res, next) {
    if (req.session.isLoggedIn) {
        next();
    } else {
        res.status(401).json({ message: 'Unauthorized: Please log in.' });
    }
}

// ===================================================================
//
//               *** ROUTING ORDER ***
//
// All specific API routes and page routes are defined *BEFORE*
// the `express.static` file server.
//
// ===================================================================

// --- AUTH ROUTES ---
app.post('/admin/login', (req, res) => {
    const { username, password } = req.body;
    if (username === ADMIN_USER && password === ADMIN_PASS) {
        req.session.isLoggedIn = true;
        res.redirect('/admin/admin.html');
    } else {
        res.redirect('/admin/login.html?error=1');
    }
});

app.get('/admin/logout', (req, res) => {
    req.session.destroy(err => {
        if (err) {
            return res.redirect('/admin/admin.html');
        }
        res.clearCookie('connect.sid');
        res.redirect('/admin/login.html');
    });
});

// --- PROTECTED ADMIN PAGE ROUTE ---
app.get('/admin/admin.html', checkAuth, (req, res) => {
    res.sendFile(path.join(__dirname, 'admin.html'));
});

// --- PUBLIC PAGE ROUTE (LOGIN) ---
app.get('/admin/login.html', (req, res) => {
    res.sendFile(path.join(__dirname, 'login.html'));
});

// --- PUBLIC API ENDPOINT ---
app.get('/api/public-data', async (req, res) => {
    console.log(`[GET /api/public-data] Reading from Supabase for public...`);
    
    const { data: posts, error: postsError } = await supabase
        .from('posts')
        .select('*')
        .eq('published', true)
        .order('id', { ascending: false });

    if (postsError) {
        console.error('Supabase error (posts):', postsError.message);
        return res.status(500).json({ message: 'Error reading posts.' });
    }

    const { data: categoriesList, error: catsError } = await supabase
        .from('categories')
        .select('name, tags');

    if (catsError) {
        console.error('Supabase error (categories):', catsError.message);
        return res.status(500).json({ message: 'Error reading categories.' });
    }

    const publicData = {
        categories: formatCategories(categoriesList),
        posts: posts || []
    };
    res.status(200).json(publicData);
});

// --- PROTECTED ADMIN API ENDPOINTS ---

// GET ALL DATA (FOR ADMIN)
app.get('/api/data', checkApiAuth, async (req, res) => {
    console.log(`[GET /api/data] Reading from Supabase for admin...`);

    const { data: posts, error: postsError } = await supabase
        .from('posts')
        .select('*')
        .order('id', { ascending: false });

    if (postsError) {
        console.error('Supabase error (posts):', postsError.message);
        return res.status(500).json({ message: 'Error reading posts.' });
    }

    const { data: categoriesList, error: catsError } = await supabase
        .from('categories')
        .select('name, tags');

    if (catsError) {
        console.error('Supabase error (categories):', catsError.message);
        return res.status(500).json({ message: 'Error reading categories.' });
    }

    const adminData = {
        categories: formatCategories(categoriesList),
        posts: posts || []
    };
    res.status(200).json(adminData);
});

// --- POST MANAGEMENT (CRUD) ROUTES ---

// CREATE: POST /api/posts
app.post('/api/posts', checkApiAuth, async (req, res) => {
    const newPost = req.body;
    console.log('[POST /api/posts] Inserting new post...');

    if (!newPost || !newPost.title || !newPost.category) {
        return res.status(400).json({ message: 'Bad Request: Missing required fields.' });
    }
    
    const { error } = await supabase.from('posts').insert(newPost);

    if (error) {
        console.error('Supabase error:', error.message);
        return res.status(500).json({ message: 'Error saving post.' });
    }
    
    console.log('Post saved successfully!');
    res.status(200).json({ message: 'Post saved successfully!' });
});

// UPDATE: PUT /api/posts/:id
app.put('/api/posts/:id', checkApiAuth, async (req, res) => {
    const postId = parseInt(req.params.id);
    const updatedPost = req.body;
    console.log(`[PUT /api/posts/${postId}] Updating post...`);

    delete updatedPost.id;
    delete updatedPost.created_at; 

    const { error } = await supabase
        .from('posts')
        .update(updatedPost)
        .eq('id', postId);

    if (error) {
        console.error('Supabase error:', error.message);
        return res.status(500).json({ message: 'Error updating post.' });
    }

    console.log('Post updated successfully!');
    res.status(200).json({ message: 'Post updated successfully!' });
});

// DELETE: DELETE /api/posts/:id
app.delete('/api/posts/:id', checkApiAuth, async (req, res) => {
    const postId = parseInt(req.params.id);
    console.log(`[DELETE /api/posts/${postId}] Deleting post...`);

    const { error } = await supabase.from('posts').delete().eq('id', postId);

    if (error) {
        console.error('Supabase error:', error.message);
        return res.status(500).json({ message: 'Error deleting post.' });
    }

    console.log('Post deleted successfully!');
    res.status(200).json({ message: 'Post deleted successfully!' });
});

// TOGGLE PUBLISH: PUT /api/posts/toggle-publish/:id
app.put('/api/posts/toggle-publish/:id', checkApiAuth, async (req, res) => {
    const postId = parseInt(req.params.id);
    console.log(`[PUT /api/posts/toggle-publish/${postId}] Toggling...`);

    const { data: post, error: fetchError } = await supabase
        .from('posts')
        .select('published')
        .eq('id', postId)
        .single(); 

    if (fetchError || !post) {
        console.error('Supabase error:', fetchError ? fetchError.message : 'Post not found');
        return res.status(404).json({ message: 'Post not found.' });
    }

    const { error: updateError } = await supabase
        .from('posts')
        .update({ published: !post.published })
        .eq('id', postId);

    if (updateError) {
        console.error('Supabase error:', updateError.message);
        return res.status(500).json({ message: 'Error updating status.' });
    }

    console.log(`Post ${postId} status set to: ${!post.published}`);
    res.status(200).json({ message: 'Publish status updated successfully!' });
});

// --- CATEGORY MANAGEMENT ---

// CREATE: POST /api/categories
app.post('/api/categories', checkApiAuth, async (req, res) => {
    const newCategoryName = req.body.name;
    console.log(`[POST /api/categories] Request to add: ${newCategoryName}`);

    if (!newCategoryName) {
        return res.status(400).json({ message: 'Category name is required.' });
    }

    const { error } = await supabase
        .from('categories')
        .insert({ name: newCategoryName, tags: [] });

    if (error) {
        if (error.code === '23505') { 
            return res.status(400).json({ message: 'Category already exists.' });
        }
        console.error('Supabase error:', error.message);
        return res.status(500).json({ message: 'Error adding category.' });
    }

    console.log(`Added new category: ${newCategoryName}`);
    res.status(200).json({ message: 'Category added successfully!' });
});

// DELETE: DELETE /api/categories/:name
app.delete('/api/categories/:name', checkApiAuth, async (req, res) => {
    const categoryToDelete = decodeURIComponent(req.params.name);
    console.log(`[DELETE /api/categories] Request to delete: ${categoryToDelete}`);

    const { error: catError } = await supabase
        .from('categories')
        .delete()
        .eq('name', categoryToDelete);

    if (catError) {
        console.error('Supabase error (deleting category):', catError.message);
        return res.status(500).json({ message: 'Error deleting category.' });
    }

    const { error: postError } = await supabase
        .from('posts')
        .update({ category: "" }) 
        .eq('category', categoryToDelete);
    
    if (postError) {
        console.error('Supabase error (updating posts):', postError.message);
    }
    
    console.log(`Deleted category: ${categoryToDelete} and updated posts.`);
    res.status(200).json({ message: 'Category deleted successfully!' });
});

// EDIT/RENAME: PUT /api/categories/:name
app.put('/api/categories/:name', checkApiAuth, async (req, res) => {
    const oldName = decodeURIComponent(req.params.name);
    const { newName } = req.body;
    console.log(`[PUT /api/categories] Request to rename '${oldName}' to '${newName}'`);

    if (!newName || newName.trim() === '') {
        return res.status(400).json({ message: 'New category name is required.' });
    }
    
    const { error: catError } = await supabase
        .from('categories')
        .update({ name: newName })
        .eq('name', oldName);

    if (catError) {
        if (catError.code === '23505') { 
            return res.status(400).json({ message: 'Category name already exists.' });
        }
        console.error('Supabase error (renaming category):', catError.message);
        return res.status(500).json({ message: 'Error renaming category.' });
    }

    const { error: postError } = await supabase
        .from('posts')
        .update({ category: newName })
        .eq('category', oldName);
    
    if (postError) {
         console.error('Supabase error (updating posts):', postError.message);
    }

    console.log(`Renamed category to '${newName}' and updated posts.`);
    res.status(200).json({ message: 'Category renamed successfully!' });
});


// --- TAG MANAGEMENT ROUTES ---

// CREATE: POST /api/tags
app.post('/api/tags', checkApiAuth, async (req, res) => {
    const { categoryName, tagName } = req.body;
    console.log(`[POST /api/tags] Request to add tag '${tagName}' to '${categoryName}'`);
    if (!categoryName || !tagName) {
        return res.status(400).json({ message: 'Category name and tag name are required.' });
    }

    const { data: category, error: fetchError } = await supabase
        .from('categories')
        .select('tags')
        .eq('name', categoryName)
        .single();
    
    if (fetchError || !category) {
        return res.status(404).json({ message: 'Category not found.' });
    }
    
    if (category.tags && category.tags.includes(tagName)) {
        return res.status(400).json({ message: 'Tag already exists in this category.' });
    }

    const newTags = [...(category.tags || []), tagName];
    const { error: updateError } = await supabase
        .from('categories')
        .update({ tags: newTags })
        .eq('name', categoryName);

    if (updateError) {
        console.error('Supabase error:', updateError.message);
        return res.status(500).json({ message: 'Error adding tag.' });
    }

    console.log('Tag added successfully');
    res.status(200).json({ message: 'Tag added successfully!' });
});

// DELETE: DELETE /api/tags/:categoryName/:tagName
app.delete('/api/tags/:categoryName/:tagName', checkApiAuth, async (req, res) => {
    const categoryName = decodeURIComponent(req.params.categoryName);
    const tagName = decodeURIComponent(req.params.tagName);
    console.log(`[DELETE /api/tags] Request to delete tag '${tagName}' from '${categoryName}'`);

    const { data: category, error: fetchError } = await supabase
        .from('categories')
        .select('tags')
        .eq('name', categoryName)
        .single();
    
    if (fetchError || !category) {
        return res.status(44).json({ message: 'Category not found.' });
    }

    if (!category.tags || !category.tags.includes(tagName)) {
        return res.status(404).json({ message: 'Tag not found in this category.' });
    }
    
    const newTags = category.tags.filter(t => t !== tagName);
    const { error: updateError } = await supabase
        .from('categories')
        .update({ tags: newTags })
        .eq('name', categoryName);

    if (updateError) {
        console.error('Supabase error (updating category):', updateError.message);
        return res.status(500).json({ message: 'Error deleting tag from category.' });
    }

    const { data: posts, error: postFetchError } = await supabase
        .from('posts')
        .select('id, tags')
        .eq('category', categoryName)
        .contains('tags', [tagName]);
    
    if (postFetchError) {
        console.error('Supabase error (fetching posts for tag removal):', postFetchError.message);
        return res.status(500).json({ message: 'Tag deleted, but failed to update posts.' });
    }

    const updates = posts.map(post => {
        return supabase
            .from('posts')
            .update({ tags: post.tags.filter(t => t !== tagName) })
            .eq('id', post.id);
    });
    
    await Promise.all(updates); 

    console.log('Tag deleted successfully and removed from posts.');
    res.status(200).json({ message: 'Tag deleted successfully!' });
});

// EDIT/RENAME: PUT /api/tags/:categoryName/:tagName
app.put('/api/tags/:categoryName/:tagName', checkApiAuth, async (req, res) => {
    const categoryName = decodeURIComponent(req.params.categoryName);
    const oldTagName = decodeURIComponent(req.params.tagName);
    const { newTagName } = req.body;
    console.log(`[PUT /api/tags] Request to rename tag '${oldTagName}' to '${newTagName}' in '${categoryName}'`);

    if (!newTagName || newName.trim() === '') {
        return res.status(400).json({ message: 'New tag name is required.' });
    }

    const { data: category, error: fetchError } = await supabase
        .from('categories')
        .select('tags')
        .eq('name', categoryName)
        .single();
    
    if (fetchError || !category) {
        return res.status(404).json({ message: 'Category not found.' });
    }
    
    if (!category.tags || !category.tags.includes(oldTagName)) {
        return res.status(404).json({ message: 'Tag to rename not found.' });
    }
    
    if (category.tags.includes(newTagName)) {
        return res.status(400).json({ message: 'Tag name already exists in this category.' });
    }

    const newTags = category.tags.map(t => (t === oldTagName ? newTagName : t));
    const { error: updateError } = await supabase
        .from('categories')
        .update({ tags: newTags })
        .eq('name', categoryName);

    if (updateError) {
        console.error('Supabase error (updating category):', updateError.message);
        return res.status(500).json({ message: 'Error renaming tag in category.' });
    }
    
    const { data: posts, error: postFetchError } = await supabase
        .from('posts')
        .select('id, tags')
        .eq('category', categoryName)
        .contains('tags', [oldTagName]);
    
    if (postFetchError) {
        console.error('Supabase error (fetching posts for tag rename):', postFetchError.message);
        return res.status(500).json({ message: 'Tag renamed, but failed to update posts.' });
    }
    
    const updates = posts.map(post => {
        return supabase
            .from('posts')
            .update({ tags: post.tags.map(t => (t === oldTagName ? newTagName : t)) })
            .eq('id', post.id);
    });
    
    await Promise.all(updates);

    console.log(`Renamed tag to '${newTagName}' and updated posts.`);
    res.status(200).json({ message: 'Tag renamed successfully!' });
});


// === ADMIN COMMENT MODERATION ROUTES ===

// GET: Fetch ALL comments (pending and approved) for admin
app.get('/api/admin/comments', checkApiAuth, async (req, res) => {
    console.log(`[GET /api/admin/comments] Fetching all comments for moderation...`);
    
    // Join with posts to get post title, which is helpful for context
    const { data: comments, error } = await supabase
        .from('comments')
        .select(`
            id,
            created_at,
            name,
            content,
            is_approved,
            post_id,
            post:posts ( title )
        `)
        .order('created_at', { ascending: false }); // Show newest first for admin

    if (error) {
        console.error('Supabase error (fetching all comments):', error.message);
        return res.status(500).json({ message: 'Error fetching comments.' });
    }
    
    res.status(200).json(comments || []);
});

// APPROVE: PUT /api/comments/approve/:id
app.put('/api/comments/approve/:id', checkApiAuth, async (req, res) => {
    const commentId = parseInt(req.params.id);
    console.log(`[PUT /api/comments/approve/${commentId}] Approving comment...`);

    const { error } = await supabase
        .from('comments')
        .update({ is_approved: true })
        .eq('id', commentId);

    if (error) {
        console.error('Supabase error (approving comment):', error.message);
        return res.status(500).json({ message: 'Error approving comment.' });
    }

    res.status(200).json({ message: 'Comment approved!' });
});

// DELETE: DELETE /api/comments/:id
app.delete('/api/comments/:id', checkApiAuth, async (req, res) => {
    const commentId = parseInt(req.params.id);
    console.log(`[DELETE /api/comments/${commentId}] Deleting comment...`);

    const { error } = await supabase
        .from('comments')
        .delete()
        .eq('id', commentId);

    if (error) {
        console.error('Supabase error (deleting comment):', error.message);
        return res.status(500).json({ message: 'Error deleting comment.' });
    }

    res.status(200).json({ message: 'Comment deleted!' });
});


// === PUBLIC COMMENT ROUTES ===

// GET: Fetch all *APPROVED* comments for a specific post
app.get('/api/comments/:postId', async (req, res) => {
    const { postId } = req.params;
    
    const { data: comments, error } = await supabase
        .from('comments')
        .select('*')
        .eq('post_id', postId)
        .eq('is_approved', true) // <-- IMPORTANT: Only show approved
        .order('created_at', { ascending: true }); // Show oldest first

    if (error) {
        console.error('Supabase error (fetching comments):', error.message);
        return res.status(500).json({ message: 'Error fetching comments.' });
    }
    
    res.status(200).json(comments || []);
});

// POST: Submit a new comment (will be 'is_approved: false' by default)
app.post('/api/comments', async (req, res) => {
    
    const { post_id, name, content } = req.body;

    // 1. Check if fields exist
    if (!post_id || !name || !content) {
        console.error('Validation failed: Missing fields.', req.body);
        return res.status(400).json({ message: 'Missing required fields (post_id, name, content).' });
    }
    
    // 2. Parse/trim them
    const numeric_post_id = parseInt(post_id, 10);
    const trimmedName = name.trim();
    const trimmedContent = content.trim();

    // 3. Check if they are empty *after* trimming
    if (!numeric_post_id || !trimmedName || !trimmedContent) {
        console.error('Validation failed: Fields are empty after trimming.');
        return res.status(400).json({ message: 'All fields must have a value.' });
    }
    
    // 4. Proceed with insert
    // === THIS IS THE FIX: .select() has been removed ===
    const { error } = await supabase
        .from('comments')
        .insert([
            { post_id: numeric_post_id, name: trimmedName, content: trimmedContent }
        ]);
    // === END FIX ===

    if (error) {
        console.error('Supabase error (inserting comment):', error.message);
        console.error('Data sent to Supabase:', { post_id: numeric_post_id, name: trimmedName, content: trimmedContent });
        return res.status(500).json({ message: 'Error posting comment.' });
    }

    console.log('New comment posted, awaiting moderation.');
    res.status(201).json({ message: 'Comment submitted for moderation!' });
});
// === END OF COMMENT ROUTES ===


// --- STATIC FILE SERVER (NOW LAST) ---
// This serves all other static files (CSS, JS, images) from the root.
app.use(express.static(path.join(__dirname, '..'), {
    index: false, // We handle the index route ourselves
    setHeaders: (res, filePath) => {
        // Block sensitive files just in case
        if (filePath.endsWith('admin.html') || filePath.endsWith('db.json')) {
            res.status(403).send('Forbidden');
        }
    }
}));

// --- ROOT PAGE ROUTE (CATCH-ALL) ---
// This must be one of the last routes.
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, '..', 'index.html'));
});


// --- Start the Server ---
app.listen(PORT, () => {
    console.log(`--- Blog Server & Admin Panel (Supabase Mode) ---`);
    console.log(`Server running on http://localhost:${PORT}`);
    console.log(`Public Blog: http://localhost:${PORT}`);
    console.log(`Admin Login: http://localhost:${PORT}/admin/login.html`);
    console.log(`-------------------------------------------------`);
});
