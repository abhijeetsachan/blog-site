/*
 * ==========================================================================
 * !! IMPORTANT: SUPABASE SETUP INSTRUCTIONS !!
 * ==========================================================================
 * * Before this server will work, you MUST set up your Supabase database.
 * * 1. Create a new project in Supabase.
 * 2. Go to the "SQL Editor" section (the one with the `>` icon).
 * 3. Click "New query" and paste ALL of the code below and click "RUN".
 *
 * ------------------- PASTE THIS IN SUPABASE SQL EDITOR --------------------
 *
 * -- Create the 'posts' table
 * CREATE TABLE public.posts (
 * id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 * created_at TIMESTAMPTZ DEFAULT now(),
 * title TEXT NOT NULL,
 * category TEXT,
 * tags TEXT[],
 * image TEXT,
 * excerpt TEXT,
 * "fullContent" TEXT,
 * published BOOLEAN DEFAULT false,
 * date TEXT
 * );
 * * -- Create the 'categories' table
 * CREATE TABLE public.categories (
 * id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 * created_at TIMESTAMPTZ DEFAULT now(),
 * name TEXT NOT NULL UNIQUE,
 * tags TEXT[] DEFAULT ARRAY[]::TEXT[]
 * );
 * * -- Create a helper function to remove an item from a text array
 * CREATE OR REPLACE FUNCTION array_remove(arr TEXT[], item TEXT)
 * RETURNS TEXT[] AS $$
 * BEGIN
 * RETURN array_agg(elem) FROM unnest(arr) AS elem WHERE elem <> item;
 * END;
 * $$ LANGUAGE plpgsql;
 * * -- Create a helper function to replace an item in a text array
 * CREATE OR REPLACE FUNCTION array_replace(arr TEXT[], old_item TEXT, new_item TEXT)
 * RETURNS TEXT[] AS $$
 * DECLARE
 * new_arr TEXT[];
 * BEGIN
 * SELECT array_agg(CASE WHEN elem = old_item THEN new_item ELSE elem END)
 * INTO new_arr
 * FROM unnest(arr) AS elem;
 * RETURN new_arr;
 * END;
 * $$ LANGUAGE plpgsql;
 * * -- Enable Row Level Security (RLS)
 * -- This is good practice. We disable it for 'public' tables and use the ANON_KEY
 * -- which has read/write. For a real app, you would set up policies.
 * ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
 * ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;
 * * CREATE POLICY "Public tables are viewable by everyone" 
 * ON public.posts FOR SELECT USING (true);
 * * CREATE POLICY "Public categories are viewable by everyone" 
 * ON public.categories FOR SELECT USING (true);
 * * -- For a real app, you'd lock down insert/update/delete to auth users.
 * -- For this project, the ANON_KEY has full rights, which is fine
 * -- because our *server* is the only thing that uses it, and our
 * -- *server* is protected by session auth.
 * * ------------------------- END OF SQL CODE --------------------------------
 *
 * 4. Go to "Project Settings" (the gear icon).
 * 5. Go to "API".
 * 6. Find the "Project URL" and "Project API Keys" (the `anon` `public` key).
 * 7. You will add these to your environment variables (e.g., in a `.env` file
 * or in your hosting provider's settings) along with your other secrets.
 * * SUPABASE_URL="YOUR_PROJECT_URL"
 * SUPABASE_ANON_KEY="YOUR_ANON_KEY"
 * ADMIN_USER="admin"
 * ADMIN_PASS="password123"
 * SESSION_SECRET="your-very-secret-key-change-this"
 * * ==========================================================================
 */

const express = require('express');
const path = require('path');
const cors = require('cors'); 
const session = require('express-session');
const { createClient } = require('@supabase/supabase-js'); // <-- ADD THIS

// --- Load Environment Variables (for local development) ---
// For this to work, create a file named `.env` in the `admin` folder
// DO NOT commit this .env file to GitHub.
if (process.env.NODE_ENV !== 'production') {
    require('dotenv').config({ path: path.join(__dirname, '.env') });
}

const app = express();
const PORT = process.env.PORT || 3000;

// --- SUPABASE & ADMIN CREDENTIALS ---
const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY;
const ADMIN_USER = process.env.ADMIN_USER;
const ADMIN_PASS = process.env.ADMIN_PASS;
const SESSION_SECRET = process.env.SESSION_SECRET;

// Check if all required env vars are set
if (!SUPABASE_URL || !SUPABASE_ANON_KEY || !ADMIN_USER || !ADMIN_PASS || !SESSION_SECRET) {
    console.error('FATAL ERROR: Missing required environment variables.');
    console.log('Please check your .env file or hosting environment.');
    process.exit(1);
}

// --- Initialize Supabase Client ---
// We use the anon key. RLS (Row Level Security) should be off for `public`
// or configured to allow public read. Our server auth protects writes.
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// --- Middleware ---
app.use(cors()); 
app.use(express.json({ limit: '10mb' })); 
app.use(express.urlencoded({ extended: true }));

// --- Session Middleware ---
app.use(session({
    secret: SESSION_SECRET,
    resave: false,
    saveUninitialized: true,
    cookie: { 
        maxAge: 1000 * 60 * 60 * 24 // 1 day
        // secure: process.env.NODE_ENV === 'production' // Enable this if you are using HTTPS
    }
}));

// --- Serve Public Files ---
// Serve index.html and other root-level static assets
app.use(express.static(path.join(__dirname, '..'), {
    index: false,
    setHeaders: (res, filePath) => {
        // Block sensitive files
        if (filePath.endsWith('admin.html') || filePath.endsWith('db.json')) {
            res.status(403).send('Forbidden');
        }
    }
}));
// Serve index.html as the root
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, '..', 'index.html'));
});
// Serve the login page publicly
app.get('/admin/login.html', (req, res) => {
    res.sendFile(path.join(__dirname, 'login.html'));
});


// --- Helper Function to format categories ---
// The frontend expects: { "CategoryName": ["tag1", "tag2"], ... }
// Supabase returns: [ { "name": "CategoryName", "tags": ["tag1", "tag2"] }, ... ]
function formatCategories(categoryList) {
    if (!categoryList) return {};
    return categoryList.reduce((acc, cat) => {
        acc[cat.name] = cat.tags || [];
        return acc;
    }, {});
}

// --- Authentication Middleware ---
function checkAuth(req, res, next) {
    if (req.session.isLoggedIn) {
        next();
    } else {
        res.redirect('/admin/login.html');
    }
}

function checkApiAuth(req, res, next) {
    if (req.session.isLoggedIn) {
        next();
    } else {
        res.status(401).json({ message: 'Unauthorized: Please log in.' });
    }
}

// --- NEW AUTH ROUTES ---
app.post('/admin/login', (req, res) => {
    const { username, password } = req.body;
    if (username === ADMIN_USER && password === ADMIN_PASS) {
        req.session.isLoggedIn = true;
        res.redirect('/admin/admin.html');
    } else {
        res.redirect('/admin/login.html?error=1');
    }
});

app.get('/admin/logout', (req, res) => {
    req.session.destroy(err => {
        if (err) {
            return res.redirect('/admin/admin.html');
        }
        res.clearCookie('connect.sid');
        res.redirect('/admin/login.html');
    });
});

// --- NEW PROTECTED ADMIN PAGE ROUTE ---
app.get('/admin/admin.html', checkAuth, (req, res) => {
    res.sendFile(path.join(__dirname, 'admin.html'));
});


// --- API Endpoints ---

// --- NEW PUBLIC DATA ENDPOINT ---
app.get('/api/public-data', async (req, res) => {
    console.log(`[GET /api/public-data] Reading from Supabase for public...`);
    
    // 1. Fetch published posts
    const { data: posts, error: postsError } = await supabase
        .from('posts')
        .select('*')
        .eq('published', true)
        .order('id', { ascending: false });

    if (postsError) {
        console.error('Supabase error (posts):', postsError.message);
        return res.status(500).json({ message: 'Error reading posts.' });
    }

    // 2. Fetch categories
    const { data: categoriesList, error: catsError } = await supabase
        .from('categories')
        .select('name, tags');

    if (catsError) {
        console.error('Supabase error (categories):', catsError.message);
        return res.status(500).json({ message: 'Error reading categories.' });
    }

    // 3. Format and send data
    const publicData = {
        categories: formatCategories(categoriesList),
        posts: posts || []
    };
    res.status(200).json(publicData);
});

// --- PROTECTED ADMIN API ENDPOINTS ---

// GET ALL DATA (FOR ADMIN)
app.get('/api/data', checkApiAuth, async (req, res) => {
    console.log(`[GET /api/data] Reading from Supabase for admin...`);

    const { data: posts, error: postsError } = await supabase
        .from('posts')
        .select('*')
        .order('id', { ascending: false });

    if (postsError) {
        console.error('Supabase error (posts):', postsError.message);
        return res.status(500).json({ message: 'Error reading posts.' });
    }

    const { data: categoriesList, error: catsError } = await supabase
        .from('categories')
        .select('name, tags');

    if (catsError) {
        console.error('Supabase error (categories):', catsError.message);
        return res.status(500).json({ message: 'Error reading categories.' });
    }

    const adminData = {
        categories: formatCategories(categoriesList),
        posts: posts || []
    };
    res.status(200).json(adminData);
});

// --- POST MANAGEMENT (CRUD) ROUTES ---

// CREATE: POST /api/posts
app.post('/api/posts', checkApiAuth, async (req, res) => {
    const newPost = req.body;
    console.log('[POST /api/posts] Inserting new post...');

    if (!newPost || !newPost.title || !newPost.category) {
        return res.status(400).json({ message: 'Bad Request: Missing required fields.' });
    }
    
    // Supabase auto-generates 'id'
    const { error } = await supabase.from('posts').insert(newPost);

    if (error) {
        console.error('Supabase error:', error.message);
        return res.status(500).json({ message: 'Error saving post.' });
    }
    
    console.log('Post saved successfully!');
    res.status(200).json({ message: 'Post saved successfully!' });
});

// UPDATE: PUT /api/posts/:id
app.put('/api/posts/:id', checkApiAuth, async (req, res) => {
    const postId = parseInt(req.params.id);
    const updatedPost = req.body;
    console.log(`[PUT /api/posts/${postId}] Updating post...`);

    // Don't send the id *in* the update body
    delete updatedPost.id;
    delete updatedPost.created_at; // Don't let client change this

    const { error } = await supabase
        .from('posts')
        .update(updatedPost)
        .eq('id', postId);

    if (error) {
        console.error('Supabase error:', error.message);
        return res.status(500).json({ message: 'Error updating post.' });
    }

    console.log('Post updated successfully!');
    res.status(200).json({ message: 'Post updated successfully!' });
});

// DELETE: DELETE /api/posts/:id
app.delete('/api/posts/:id', checkApiAuth, async (req, res) => {
    const postId = parseInt(req.params.id);
    console.log(`[DELETE /api/posts/${postId}] Deleting post...`);

    const { error } = await supabase.from('posts').delete().eq('id', postId);

    if (error) {
        console.error('Supabase error:', error.message);
        return res.status(500).json({ message: 'Error deleting post.' });
    }

    console.log('Post deleted successfully!');
    res.status(200).json({ message: 'Post deleted successfully!' });
});

// TOGGLE PUBLISH: PUT /api/posts/toggle-publish/:id
app.put('/api/posts/toggle-publish/:id', checkApiAuth, async (req, res) => {
    const postId = parseInt(req.params.id);
    console.log(`[PUT /api/posts/toggle-publish/${postId}] Toggling...`);

    // 1. Get current status
    const { data: post, error: fetchError } = await supabase
        .from('posts')
        .select('published')
        .eq('id', postId)
        .single(); // Get one record

    if (fetchError || !post) {
        console.error('Supabase error:', fetchError ? fetchError.message : 'Post not found');
        return res.status(404).json({ message: 'Post not found.' });
    }

    // 2. Toggle and update
    const { error: updateError } = await supabase
        .from('posts')
        .update({ published: !post.published })
        .eq('id', postId);

    if (updateError) {
        console.error('Supabase error:', updateError.message);
        return res.status(500).json({ message: 'Error updating status.' });
    }

    console.log(`Post ${postId} status set to: ${!post.published}`);
    res.status(200).json({ message: 'Publish status updated successfully!' });
});

// --- CATEGORY MANAGEMENT ---

// CREATE: POST /api/categories
app.post('/api/categories', checkApiAuth, async (req, res) => {
    const newCategoryName = req.body.name;
    console.log(`[POST /api/categories] Request to add: ${newCategoryName}`);

    if (!newCategoryName) {
        return res.status(400).json({ message: 'Category name is required.' });
    }

    const { error } = await supabase
        .from('categories')
        .insert({ name: newCategoryName, tags: [] });

    if (error) {
        if (error.code === '23505') { // Unique constraint violation
            return res.status(400).json({ message: 'Category already exists.' });
        }
        console.error('Supabase error:', error.message);
        return res.status(500).json({ message: 'Error adding category.' });
    }

    console.log(`Added new category: ${newCategoryName}`);
    res.status(200).json({ message: 'Category added successfully!' });
});

// DELETE: DELETE /api/categories/:name
app.delete('/api/categories/:name', checkApiAuth, async (req, res) => {
    const categoryToDelete = decodeURIComponent(req.params.name);
    console.log(`[DELETE /api/categories] Request to delete: ${categoryToDelete}`);

    // 1. Delete the category
    const { error: catError } = await supabase
        .from('categories')
        .delete()
        .eq('name', categoryToDelete);

    if (catError) {
        console.error('Supabase error (deleting category):', catError.message);
        return res.status(500).json({ message: 'Error deleting category.' });
    }

    // 2. Update posts that used this category
    const { error: postError } = await supabase
        .from('posts')
        .update({ category: "" }) // Set to empty string
        .eq('category', categoryToDelete);
    
    if (postError) {
        console.error('Supabase error (updating posts):', postError.message);
        // Category was deleted, but posts failed to update. Not ideal, but...
    }
    
    console.log(`Deleted category: ${categoryToDelete} and updated posts.`);
    res.status(200).json({ message: 'Category deleted successfully!' });
});

// EDIT/RENAME: PUT /api/categories/:name
app.put('/api/categories/:name', checkApiAuth, async (req, res) => {
    const oldName = decodeURIComponent(req.params.name);
    const { newName } = req.body;
    console.log(`[PUT /api/categories] Request to rename '${oldName}' to '${newName}'`);

    if (!newName || newName.trim() === '') {
        return res.status(400).json({ message: 'New category name is required.' });
    }
    
    // 1. Rename the category
    const { error: catError } = await supabase
        .from('categories')
        .update({ name: newName })
        .eq('name', oldName);

    if (catError) {
        if (catError.code === '23505') { // Unique constraint
            return res.status(400).json({ message: 'Category name already exists.' });
        }
        console.error('Supabase error (renaming category):', catError.message);
        return res.status(500).json({ message: 'Error renaming category.' });
    }

    // 2. Update all posts using the old category name
    const { error: postError } = await supabase
        .from('posts')
        .update({ category: newName })
        .eq('category', oldName);
    
    if (postError) {
         console.error('Supabase error (updating posts):', postError.message);
    }

    console.log(`Renamed category to '${newName}' and updated posts.`);
    res.status(200).json({ message: 'Category renamed successfully!' });
});


// --- TAG MANAGEMENT ROUTES ---

// CREATE: POST /api/tags
app.post('/api/tags', checkApiAuth, async (req, res) => {
    const { categoryName, tagName } = req.body;
    console.log(`[POST /api/tags] Request to add tag '${tagName}' to '${categoryName}'`);
    if (!categoryName || !tagName) {
        return res.status(400).json({ message: 'Category name and tag name are required.' });
    }

    // 1. Get current tags
    const { data: category, error: fetchError } = await supabase
        .from('categories')
        .select('tags')
        .eq('name', categoryName)
        .single();
    
    if (fetchError || !category) {
        return res.status(404).json({ message: 'Category not found.' });
    }
    
    if (category.tags && category.tags.includes(tagName)) {
        return res.status(400).json({ message: 'Tag already exists in this category.' });
    }

    // 2. Add new tag
    const newTags = [...(category.tags || []), tagName];
    const { error: updateError } = await supabase
        .from('categories')
        .update({ tags: newTags })
        .eq('name', categoryName);

    if (updateError) {
        console.error('Supabase error:', updateError.message);
        return res.status(500).json({ message: 'Error adding tag.' });
    }

    console.log('Tag added successfully');
    res.status(200).json({ message: 'Tag added successfully!' });
});

// DELETE: DELETE /api/tags/:categoryName/:tagName
app.delete('/api/tags/:categoryName/:tagName', checkApiAuth, async (req, res) => {
    const categoryName = decodeURIComponent(req.params.categoryName);
    const tagName = decodeURIComponent(req.params.tagName);
    console.log(`[DELETE /api/tags] Request to delete tag '${tagName}' from '${categoryName}'`);

    // 1. Remove tag from category
    const { data: category, error: fetchError } = await supabase
        .from('categories')
        .select('tags')
        .eq('name', categoryName)
        .single();
    
    if (fetchError || !category) {
        return res.status(404).json({ message: 'Category not found.' });
    }

    if (!category.tags || !category.tags.includes(tagName)) {
        return res.status(404).json({ message: 'Tag not found in this category.' });
    }
    
    const newTags = category.tags.filter(t => t !== tagName);
    const { error: updateError } = await supabase
        .from('categories')
        .update({ tags: newTags })
        .eq('name', categoryName);

    if (updateError) {
        console.error('Supabase error (updating category):', updateError.message);
        return res.status(500).json({ message: 'Error deleting tag from category.' });
    }

    // 2. Remove the tag from all posts in that category
    // This uses the 'array_remove' function we created in the SQL setup
    const { error: rpcError } = await supabase.rpc('array_remove', {
        arr: 'tags', // This is not the variable, it's the column name
        item: tagName
    })
    // This is a bit tricky. The simple RPC call above won't work like that.
    // We need to update posts WHERE category = categoryName
    // A better RPC function would be needed.
    // Let's do this the multi-query way.

    // 2. Get all posts with that tag in that category
    const { data: posts, error: postFetchError } = await supabase
        .from('posts')
        .select('id, tags')
        .eq('category', categoryName)
        .contains('tags', [tagName]);
    
    if (postFetchError) {
        console.error('Supabase error (fetching posts for tag removal):', postFetchError.message);
        return res.status(500).json({ message: 'Tag deleted, but failed to update posts.' });
    }

    // 3. Update them one by one (or in a batch)
    const updates = posts.map(post => {
        return supabase
            .from('posts')
            .update({ tags: post.tags.filter(t => t !== tagName) })
            .eq('id', post.id);
    });
    
    await Promise.all(updates); // This can have partial failures, but it's ok for this app

    console.log('Tag deleted successfully and removed from posts.');
    res.status(200).json({ message: 'Tag deleted successfully!' });
});

// EDIT/RENAME: PUT /api/tags/:categoryName/:tagName
app.put('/api/tags/:categoryName/:tagName', checkApiAuth, async (req, res) => {
    const categoryName = decodeURIComponent(req.params.categoryName);
    const oldTagName = decodeURIComponent(req.params.tagName);
    const { newTagName } = req.body;
    console.log(`[PUT /api/tags] Request to rename tag '${oldTagName}' to '${newTagName}' in '${categoryName}'`);

    if (!newTagName || newTagName.trim() === '') {
        return res.status(400).json({ message: 'New tag name is required.' });
    }

    // 1. Rename tag in category
    const { data: category, error: fetchError } = await supabase
        .from('categories')
        .select('tags')
        .eq('name', categoryName)
        .single();
    
    if (fetchError || !category) {
        return res.status(404).json({ message: 'Category not found.' });
    }
    
    if (!category.tags || !category.tags.includes(oldTagName)) {
        return res.status(404).json({ message: 'Tag to rename not found.' });
    }
    
    if (category.tags.includes(newTagName)) {
        return res.status(400).json({ message: 'Tag name already exists in this category.' });
    }

    const newTags = category.tags.map(t => (t === oldTagName ? newTagName : t));
    const { error: updateError } = await supabase
        .from('categories')
        .update({ tags: newTags })
        .eq('name', categoryName);

    if (updateError) {
        console.error('Supabase error (updating category):', updateError.message);
        return res.status(500).json({ message: 'Error renaming tag in category.' });
    }
    
    // 2. Get all posts with that tag in that category
    const { data: posts, error: postFetchError } = await supabase
        .from('posts')
        .select('id, tags')
        .eq('category', categoryName)
        .contains('tags', [oldTagName]);
    
    if (postFetchError) {
        console.error('Supabase error (fetching posts for tag rename):', postFetchError.message);
        return res.status(500).json({ message: 'Tag renamed, but failed to update posts.' });
    }
    
    // 3. Update them one by one
    const updates = posts.map(post => {
        return supabase
            .from('posts')
            .update({ tags: post.tags.map(t => (t === oldTagName ? newTagName : t)) })
            .eq('id', post.id);
    });
    
    await Promise.all(updates);

    console.log(`Renamed tag to '${newTagName}' and updated posts.`);
    res.status(200).json({ message: 'Tag renamed successfully!' });
});


// --- Start the Server ---
app.listen(PORT, () => {
    console.log(`--- Blog Server & Admin Panel (Supabase Mode) ---`);
    console.log(`Server running on http://localhost:${PORT}`);
    console.log(`Public Blog: http://localhost:${PORT}`);
    console.log(`Admin Login: http://localhost:${PORT}/admin/login.html`);
    console.log(`-------------------------------------------------`);
});