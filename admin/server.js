/*
 * ==========================================================================
 * !! IMPORTANT: SUPABASE SETUP INSTRUCTIONS !!
 * ==========================================================================
 * * Before this server will work, you MUST set up your Supabase database.
 * * 1. Create a new project in Supabase.
 * 2. Go to the "SQL Editor" section (the one with the `>` icon).
 * 3. Click "New query" and paste ALL of the code below and click "RUN".
 *
 * ------------------- PASTE THIS IN SUPABASE SQL EDITOR --------------------
 *
 * -- Create the 'posts' table
 * CREATE TABLE public.posts (
 * id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 * created_at TIMESTAMPTZ DEFAULT now(),
 * title TEXT NOT NULL,
 * category TEXT,
 * tags TEXT[],
 * image TEXT,
 * excerpt TEXT,
 * "fullContent" TEXT,
 * published BOOLEAN DEFAULT false,
 * date TEXT,
 * likes INT DEFAULT 0
 * );
 *
 * -- Create the 'categories' table
 * CREATE TABLE public.categories (
 * id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 * created_at TIMESTAMPTZ DEFAULT now(),
 * name TEXT NOT NULL UNIQUE,
 * tags TEXT[] DEFAULT ARRAY[]::TEXT[]
 * );
 *
 * -- Create the 'comments' table WITH moderation
 * CREATE TABLE public.comments (
 * id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 * created_at TIMESTAMPTZ DEFAULT now(),
 * post_id BIGINT NOT NULL,
 * name TEXT NOT NULL,
 * content TEXT NOT NULL,
 * is_approved BOOLEAN DEFAULT false,
 * CONSTRAINT comments_post_id_fkey FOREIGN KEY (post_id)
 * REFERENCES public.posts (id) ON DELETE CASCADE
 * );
 *
 * * -- Create a helper function to remove an item from a text array
 * CREATE OR REPLACE FUNCTION array_remove(arr TEXT[], item TEXT)
 * RETURNS TEXT[] AS $$
 * BEGIN
 * RETURN array_agg(elem) FROM unnest(arr) AS elem WHERE elem <> item;
 * END;
 * $$ LANGUAGE plpgsql;
 * * -- Create a helper function to replace an item in a text array
 * CREATE OR REPLACE FUNCTION array_replace(arr TEXT[], old_item TEXT, new_item TEXT)
 * RETURNS TEXT[] AS $$
 * DECLARE
 * new_arr TEXT[];
 * BEGIN
 * SELECT array_agg(CASE WHEN elem = old_item THEN new_item ELSE elem END)
 * INTO new_arr
 * FROM unnest(arr) AS elem;
 * RETURN new_arr;
 * END;
 * $$ LANGUAGE plpgsql;
 *
 * -- NEW: Create a function to increment likes
 * CREATE OR REPLACE FUNCTION increment_likes(post_id_to_inc BIGINT)
 * RETURNS void AS $$
 * UPDATE public.posts SET likes = likes + 1 WHERE id = post_id_to_inc
 * $$ LANGUAGE sql VOLATILE;
 *
 * -- Enable Row Level Security (RLS) for all tables
 * ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
 * ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;
 * ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;
 *
 * -- Create policies for 'posts' and 'categories'
 * CREATE POLICY "Public tables are viewable by everyone" 
 * ON public.posts FOR SELECT USING (true);
 * CREATE POLICY "Public categories are viewable by everyone" 
 * ON public.categories FOR SELECT USING (true);
 *
 * -- Create policies for 'comments'
 * CREATE POLICY "Public can only see approved comments"
 * ON public.comments FOR SELECT
 * USING (is_approved = true);
 *
 * CREATE POLICY "Anyone can create comments"
 * ON public.comments
 * FOR INSERT
 * TO anon -- This explicitly names the public (anonymous) role
 * WITH CHECK (true);
 * * * ------------------------- END OF SQL CODE --------------------------------
 *
 * 4. Go to "Project Settings" (the gear icon).
 * 5. Go to "API".
 * 6. Find the "Project URL", "anon" "public" key, and "service_role" "secret" key.
 * 7. You will add these to your environment variables (e.g., in a `.env` file
 * or in your hosting provider's settings) along with your other secrets.
 * * SUPABASE_URL="YOUR_PROJECT_URL"
 * SUPABASE_ANON_KEY="YOUR_ANON_KEY" (This is still needed for public)
 * SUPABASE_SERVICE_KEY="YOUR_SERVICE_ROLE_KEY" (This is the new one)
 * ADMIN_USER="admin"
 * ADMIN_PASS="password123"
 * SESSION_SECRET="your-very-secret-key-change-this"
 * * ==========================================================================
 */

const express = require('express');
const path = require('path');
const cors = require('cors'); 
const session = require('express-session');
const { createClient } = require('@supabase/supabase-js');
const rateLimit = require('express-rate-limit'); // <-- Added for rate limiting

// --- Load Environment Variables (for local development) ---
if (process.env.NODE_ENV !== 'production') {
    require('dotenv').config({ path: path.join(__dirname, '.env') });
}

const app = express();
// Render provides the PORT environment variable
const PORT = process.env.PORT || 3000;

// --- SUPABASE & ADMIN CREDENTIALS ---
const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY;
// === NEW: Add the Service Role Key ===
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_KEY;
const ADMIN_USER = process.env.ADMIN_USER;
const ADMIN_PASS = process.env.ADMIN_PASS;
const SESSION_SECRET = process.env.SESSION_SECRET;

// === MODIFIED: Check for the new key ===
if (!SUPABASE_URL || !SUPABASE_ANON_KEY || !SUPABASE_SERVICE_KEY || !ADMIN_USER || !ADMIN_PASS || !SESSION_SECRET) {
    console.error('FATAL ERROR: Missing required environment variables. (SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_KEY, ADMIN_USER, ADMIN_PASS, SESSION_SECRET)');
    console.log('Please check your .env file or hosting environment.');
    process.exit(1);
}

// === MODIFIED: Initialize Supabase Client with the Service Role Key ===
// This gives the server "admin" rights, bypassing RLS.
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);
// === END MODIFICATION ===

// --- Middleware ---
app.use(cors()); 
app.use(express.json({ limit: '10mb' })); 
app.use(express.urlencoded({ extended: true }));


// === CSP FIX: Get Supabase Domain Once in Global Scope (Safest method) ===
const getSupabaseDomain = (url) => {
    try {
        // Use a standard URL object to safely parse the domain
        return url ? new URL(url).hostname : '';
    } catch (e) {
        console.error('Invalid SUPABASE_URL format for CSP. Check environment variable.');
        return '';
    }
};

// Define the domain as a constant, safely outside the middleware execution
const SUPABASE_DOMAIN = getSupabaseDomain(SUPABASE_URL);


// --- NEW: SET CONTENT SECURITY POLICY (CSP) ---
app.use((req, res, next) => {
  res.setHeader(
    'Content-Security-Policy',
    "default-src 'self'; " +
    "script-src 'self' https://cdn.tailwindcss.com https://unpkg.com https://cdn.tiny.cloud 'unsafe-eval'; " +
    "style-src 'self' https://fonts.googleapis.com https://cdnjs.cloudflare.com 'unsafe-inline'; " +
    "font-src 'self' https://fonts.gstatic.com; " +
    "img-src 'self' https: data:; " +
    // Concatenate the global constant for minimal risk of SyntaxError
    "connect-src 'self' https://raw.githubusercontent.com https://" + SUPABASE_DOMAIN + "; " + 
    "frame-src 'self' https://cdn.tiny.cloud"
  );
  next();
});

// --- Session Middleware ---
app.use(session({
    secret: SESSION_SECRET,
    resave: false,
    saveUninitialized: true,
    cookie: { 
        maxAge: 1000 * 60 * 60 * 24 // 1 day
        // secure: process.env.NODE_ENV === 'production' // Enable this if you are using HTTPS
    }
}));

// --- RATE LIMITERS ---
// Limiter for login attempts (protects against brute-force)
const loginLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 10, // Max 10 login attempts per 15 minutes per IP
    message: 'Too many login attempts from this IP, please try again after 15 minutes',
    standardHeaders: true, // Return rate limit info in 'RateLimit-*' headers
    legacyHeaders: false, // Disable 'X-RateLimit-*' headers
});

// Limiter for "like" submissions (protects against spam)
const likeLimiter = rateLimit({
    windowMs: 60 * 60 * 1000, // 1 hour
    max: 5, // Max 5 like requests per hour per IP
    message: 'Too many like requests from this IP, please try again after an hour',
    standardHeaders: true,
    legacyHeaders: false,
});


// --- Helper Function to format categories ---
function formatCategories(categoryList) {
    if (!categoryList) return {};
    return categoryList.reduce((acc, cat) => {
        acc[cat.name] = cat.tags || [];
        return acc;
    }, {});
}

// --- Authentication Middleware ---
function checkAuth(req, res, next) {
    if (req.session.isLoggedIn) {
        next();
    } else {
        res.redirect('/admin/login.html');
    }
}

function checkApiAuth(req, res, next) {
    if (req.session.isLoggedIn) {
        next();
    } else {
        res.status(401).json({ message: 'Unauthorized: Please log in.' });
    }
}

// ===================================================================
//
//               *** ROUTING ORDER ***
//
// All specific API routes and page routes are defined *BEFORE*
// the `express.static` file server.
//
// ===================================================================

// --- AUTH ROUTES ---
app.post('/admin/login', loginLimiter, (req, res) => {
    const { username, password } = req.body;
    if (username === ADMIN_USER && password === ADMIN_PASS) {
        req.session.isLoggedIn = true;
        res.redirect('/admin/admin.html');
    } else {
        res.redirect('/admin/login.html?error=1');
    }
});

app.get('/admin/logout', (req, res) => {
    req.session.destroy(err => {
        if (err) {
            return res.redirect('/admin/admin.html');
        }
        res.clearCookie('connect.sid');
        res.redirect('/admin/login.html');
    });
});

// --- PROTECTED ADMIN PAGE ROUTE ---
app.get('/admin/admin.html', checkAuth, (req, res) => {
    res.sendFile(path.join(__dirname, 'admin.html'));
});

// --- PUBLIC PAGE ROUTE (LOGIN) ---
app.get('/admin/login.html', (req, res) => {
    res.sendFile(path.join(__dirname, 'login.html'));
});

// --- PUBLIC API ENDPOINT ---
app.get('/api/public-data', async (req, res) => {
    console.log(`[GET /api/public-data] Reading from Supabase for public...`);
    
    // Select * will now include the 'likes' column
    const { data: posts, error: postsError } = await supabase
        .from('posts')
        .select('*') 
        .eq('published', true)
        .order('id', { ascending: false });

    if (postsError) {
        console.error('Supabase error (posts):', postsError.message);
        return res.status(500).json({ message: 'Error reading posts.' });
    }

    const { data: categoriesList, error: catsError } = await supabase
        .from('categories')
        .select('name, tags');

    if (catsError) {
        console.error('Supabase error (categories):', catsError.message);
        return res.status(500).json({ message: 'Error reading categories.' });
    }

    const publicData = {
        categories: formatCategories(categoriesList),
        posts: posts || []
    };
    res.status(200).json(publicData);
});

// --- PROTECTED ADMIN API ENDPOINTS ---

// GET ALL DATA (FOR ADMIN)
app.get('/api/data', checkApiAuth, async (req, res) => {
    console.log(`[GET /api/data] Reading from Supabase for admin...`);

    const { data: posts, error: postsError } = await supabase
        .from('posts')
        .select('*')
        .order('id', { ascending: false });

    if (postsError) {
        console.error('Supabase error (posts):', postsError.message);
        return res.status(500).json({ message: 'Error reading posts.' });
    }

    const { data: categoriesList, error: catsError } = await supabase
        .from('categories')
        .select('name, tags');

    if (catsError) {
        console.error('Supabase error (categories):', catsError.message);
        return res.status(500).json({ message: 'Error reading categories.' });
    }

    const adminData = {
        categories: formatCategories(categoriesList),
        posts: posts || []
    };
    res.status(200).json(adminData);
});

// --- POST MANAGEMENT (CRUD) ROUTES ---

// CREATE: POST /api/posts
app.post('/api/posts', checkApiAuth, async (req, res) => {
    const newPost = req.body;
    console.log('[POST /api/posts] Inserting new post...');

    if (!newPost || !newPost.title || !newPost.category) {
        return res.status(400).json({ message: 'Bad Request: Missing required fields.' });
    }
    
    // 'likes' will default to 0 per the schema
    const { error } = await supabase.from('posts').insert(newPost);

    if (error) {
        console.error('Supabase error:', error.message);
        return res.status(500).json({ message: 'Error saving post.' });
    }
    
    console.log('Post saved successfully!');
    res.status(200).json({ message: 'Post saved successfully!' });
});

// UPDATE: PUT /api/posts/:id
app.put('/api/posts/:id', checkApiAuth, async (req, res) => {
    const postId = parseInt(req.params.id);
    const updatedPost = req.body;
    console.log(`[PUT /api/posts/${postId}] Updating post...`);

    delete updatedPost.id;
    delete updatedPost.created_at; 
    // We don't delete 'likes', as it's just part of the post data
    // If we wanted to prevent 'likes' from being edited here, we'd delete it:
    // delete updatedPost.likes;

    const { error } = await supabase
        .from('posts')
        .update(updatedPost)
        .eq('id', postId);

    if (error) {
        console.error('Supabase error:', error.message);
        return res.status(500).json({ message: 'Error updating post.' });
    }

    console.log('Post updated successfully!');
    res.status(200).json({ message: 'Post updated successfully!' });
});

// DELETE: DELETE /api/posts/:id
app.delete('/api/posts/:id', checkApiAuth, async (req, res) => {
    const postId = parseInt(req.params.id);
    console.log(`[DELETE /api/posts/${postId}] Deleting post...`);

    const { error } = await supabase.from('posts').delete().eq('id', postId);

    if (error) {
        console.error('Supabase error:', error.message);
        return res.status(500).json({ message: 'Error deleting post.' });
    }

    console.log('Post deleted successfully!');
    res.status(200).json({ message: 'Post deleted successfully!' });
});

// TOGGLE PUBLISH: PUT /api/posts/toggle-publish/:id
app.put('/api/posts/toggle-publish/:id', checkApiAuth, async (req, res) => {
    const postId = parseInt(req.params.id);
    console.log(`[PUT /api/posts/toggle-publish/${postId}] Toggling...`);

    const { data: post, error: fetchError } = await supabase
        .from('posts')
        .select('published')
        .eq('id', postId)
        .single(); 

    if (fetchError || !post) {
        console.error('Supabase error:', fetchError ? fetchError.message : 'Post not found');
        return res.status(404).json({ message: 'Post not found.' });
    }

    const { error: updateError } = await supabase
        .from('posts')
        .update({ published: !post.published })
        .eq('id', postId);

    if (updateError) {
        console.error('Supabase error:', updateError.message);
        return res.status(500).json({ message: 'Error updating status.' });
    }

    console.log(`Post ${postId} status set to: ${!post.published}`);
    res.status(200).json({ message: 'Publish status updated successfully!' });
});

// --- CATEGORY MANAGEMENT ---

// CREATE: POST /api/categories
app.post('/api/categories', checkApiAuth, async (req, res) => {
    const newCategoryName = req.body.name;
    console.log(`[POST /api/categories] Request to add: ${newCategoryName}`);

    if (!newCategoryName) {
        return res.status(400).json({ message: 'Category name is required.' });
    }

    const { error } = await supabase
        .from('categories')
        .insert({ name: newCategoryName, tags: [] });

    if (error) {
        if (error.code === '23505') { 
            return res.status(400).json({ message: 'Category already exists.' });
        }
        console.error('Supabase error:', error.message);
        return res.status(500).json({ message: 'Error adding category.' });
    }

    console.log(`Added new category: ${newCategoryName}`);
    res.status(200).json({ message: 'Category added successfully!' });
});

// DELETE: DELETE /api/categories/:name
app.delete('/api/categories/:name', checkApiAuth, async (req, res) => {
    const categoryToDelete = decodeURIComponent(req.params.name);
    console.log(`[DELETE /api/categories] Request to delete: ${categoryToDelete}`);

    const { error: catError } = await supabase
        .from('categories')
        .delete()
        .eq('name', categoryToDelete);

    if (catError) {
        console.error('Supabase error (deleting category):', catError.message);
        return res.status(500).json({ message: 'Error deleting category.' });
    }

    const { error: postError } = await supabase
        .from('posts')
        .update({ category: "" }) 
        .eq('category', categoryToDelete);
    
    if (postError) {
        console.error('Supabase error (updating posts):', postError.message);
    }
    
    console.log(`Deleted category: ${categoryToDelete} and updated posts.`);
    res.status(200).json({ message: 'Category deleted successfully!' });
});

// EDIT/RENAME: PUT /api/categories/:name
app.put('/api/categories/:name', checkApiAuth, async (req, res) => {
    const oldName = decodeURIComponent(req.params.name);
    const { newName } = req.body;
    console.log(`[PUT /api/categories] Request to rename '${oldName}' to '${newName}'`);

    if (!newName || newName.trim() === '') {
        return res.status(400).json({ message: 'New category name is required.' });
    }
    
    const { error: catError } = await supabase
        .from('categories')
        .update({ name: newName })
        .eq('name', oldName);

    if (catError) {
        if (catError.code === '23505') { 
            return res.status(400).json({ message: 'Category name already exists.' });
        }
        console.error('Supabase error (renaming category):', catError.message);
        return res.status(500).json({ message: 'Error renaming category.' });
    }

    const { error: postError } = await supabase
        .from('posts')
        .update({ category: newName })
        .eq('category', oldName);
    
    if (postError) {
         console.error('Supabase error (updating posts):', postError.message);
    }

    console.log(`Renamed category to '${newName}' and updated posts.`);
    res.status(200).json({ message: 'Category renamed successfully!' });
});


// --- TAG MANAGEMENT ROUTES ---

// CREATE: POST /api/tags
app.post('/api/tags', checkApiAuth, async (req, res) => {
    const { categoryName, tagName } = req.body;
    console.log(`[POST /api/tags] Request to add tag '${tagName}' to '${categoryName}'`);
    if (!categoryName || !tagName) {
        return res.status(400).json({ message: 'Category name and tag name are required.' });
    }

    const { data: category, error: fetchError } = await supabase
        .from('categories')
        .select('tags')
        .eq('name', categoryName)
        .single();
    
    if (fetchError || !category) {
        return res.status(404).json({ message: 'Category not found.' });
    }
    
    if (category.tags && category.tags.includes(tagName)) {
        return res.status(400).json({ message: 'Tag already exists in this category.' });
    }

    const newTags = [...(category.tags || []), tagName];
    const { error: updateError } = await supabase
        .from('categories')
        .update({ tags: newTags })
        .eq('name', categoryName);

    if (updateError) {
        console.error('Supabase error:', updateError.message);
        return res.status(500).json({ message: 'Error adding tag.' });
    }

    console.log('Tag added successfully');
    res.status(200).json({ message: 'Tag added successfully!' });
});

// DELETE: DELETE /api/tags/:categoryName/:tagName
app.delete('/api/tags/:categoryName/:tagName', checkApiAuth, async (req, res) => {
    const categoryName = decodeURIComponent(req.params.categoryName);
    const tagName = decodeURIComponent(req.params.tagName);
    console.log(`[DELETE /api/tags] Request to delete tag '${tagName}' from '${categoryName}'`);

    const { data: category, error: fetchError } = await supabase
        .from('categories')
        .select('tags')
        .eq('name', categoryName)
        .single();
    
    if (fetchError || !category) {
        return res.status(404).json({ message: 'Category not found.' });
    }

    if (!category.tags || !category.tags.includes(tagName)) {
        return res.status(404).json({ message: 'Tag not found in this category.' });
    }
    
    const newTags = category.tags.filter(t => t !== tagName);
    const { error: updateError } = await supabase
        .from('categories')
        .update({ tags: newTags })
        .eq('name', categoryName);

    if (updateError) {
        console.error('Supabase error (updating category):', updateError.message);
        return res.status(500).json({ message: 'Error deleting tag from category.' });
    }

    const { data: posts, error: postFetchError } = await supabase
        .from('posts')
        .select('id, tags')
        .eq('category', categoryName)
        .contains('tags', [tagName]);
    
    if (postFetchError) {
        console.error('Supabase error (fetching posts for tag removal):', postFetchError.message);
        return res.status(500).json({ message: 'Tag deleted, but failed to update posts.' });
    }

    const updates = posts.map(post => {
        return supabase
            .from('posts')
            .update({ tags: post.tags.filter(t => t !== tagName) })
            .eq('id', post.id);
    });
    
    await Promise.all(updates); 

    console.log('Tag deleted successfully and removed from posts.');
    res.status(200).json({ message: 'Tag deleted successfully!' });
});

// EDIT/RENAME: PUT /api/tags/:categoryName/:tagName
app.put('/api/tags/:categoryName/:tagName', checkApiAuth, async (req, res) => {
    const categoryName = decodeURIComponent(req.params.categoryName);
    const oldTagName = decodeURIComponent(req.params.tagName);
    const { newTagName } = req.body;
    console.log(`[PUT /api/tags] Request to rename tag '${oldTagName}' to '${newTagName}' in '${categoryName}'`);

    if (!newTagName || newTagName.trim() === '') {
        return res.status(400).json({ message: 'New tag name is required.' });
    }

    const { data: category, error: fetchError } = await supabase
        .from('categories')
        .select('tags')
        .eq('name', categoryName)
        .single();
    
    if (fetchError || !category) {
        return res.status(404).json({ message: 'Category not found.' });
    }
    
    if (!category.tags || !category.tags.includes(oldTagName)) {
        return res.status(404).json({ message: 'Tag to rename not found.' });
    }
    
    if (category.tags.includes(newTagName)) {
        return res.status(400).json({ message: 'Tag name already exists in this category.' });
    }

    const newTags = category.tags.map(t => (t === oldTagName ? newTagName : t));
    const { error: updateError } = await supabase
        .from('categories')
        .update({ tags: newTags })
        .eq('name', categoryName);

    if (updateError) {
        console.error('Supabase error (updating category):', updateError.message);
        return res.status(500).json({ message: 'Error renaming tag in category.' });
    }
    
    const { data: posts, error: postFetchError } = await supabase
        .from('posts')
        .select('id, tags')
        .eq('category', categoryName)
        .contains('tags', [oldTagName]);
    
    if (postFetchError) {
        console.error('Supabase error (fetching posts for tag rename):', postFetchError.message);
        return res.status(500).json({ message: 'Tag renamed, but failed to update posts.' });
    }
    
    const updates = posts.map(post => {
        return supabase
            .from('posts')
            .update({ tags: post.tags.map(t => (t === oldTagName ? newTagName : t)) })
            .eq('id', post.id);
    });
    
    await Promise.all(updates);

    console.log(`Renamed tag to '${newTagName}' and updated posts.`);
    res.status(200).json({ message: 'Tag renamed successfully!' });
});


// === ADMIN COMMENT MODERATION ROUTES ===

// GET: Fetch ALL comments (pending and approved) for admin
app.get('/api/admin/comments', checkApiAuth, async (req, res) => {
    console.log(`[GET /api/admin/comments] Fetching all comments for moderation...`);
    
    // Join with posts to get post title, which is helpful for context
    const { data: comments, error } = await supabase
        .from('comments')
        .select(\`
            id,
            created_at,
            name,
            content,
            is_approved,
            post_id,
            post:posts ( title )
        \`)
        .order('created_at', { ascending: false }); // Show newest first for admin

    if (error) {
        console.error('Supabase error (fetching all comments):', error.message);
        return res.status(500).json({ message: 'Error fetching comments.' });
    }
    
    res.status(200).json(comments || []);
});

// APPROVE: PUT /api/comments/approve/:id
app.put('/api/comments/approve/:id', checkApiAuth, async (req, res) => {
    const commentId = parseInt(req.params.id);
    console.log(`[PUT /api/comments/approve/${commentId}] Approving comment...`);

    const { error } = await supabase
        .from('comments')
        .update({ is_approved: true })
        .eq('id', commentId);

    if (error) {
        console.error('Supabase error (approving comment):', error.message);
        return res.status(500).json({ message: 'Error approving comment.' });
    }

    res.status(200).json({ message: 'Comment approved!' });
});

// DELETE: DELETE /api/comments/:id
app.delete('/api/comments/:id', checkApiAuth, async (req, res) => {
    const commentId = parseInt(req.params.id);
    console.log(`[DELETE /api/comments/${commentId}] Deleting comment...`);

    const { error } = await supabase
        .from('comments')
        .delete()
        .eq('id', commentId);

    if (error) {
        console.error('Supabase error (deleting comment):', error.message);
        // *** FIX APPLIED: Corrected typo 5D to 500 ***
        return res.status(500).json({ message: 'Error deleting comment.' }); 
    }

    res.status(200).json({ message: 'Comment deleted!' });
});


// === PUBLIC COMMENT ROUTES ===

// GET: Fetch all *APPROVED* comments for a specific post
app.get('/api/comments/:postId', async (req, res) => {
    const { postId } = req.params;
    
    const { data: comments, error } = await supabase
        .from('comments')
        .select('*')
        .eq('post_id', postId)
        .eq('is_approved', true) // <-- IMPORTANT: Only show approved
        .order('created_at', { ascending: true }); // Show oldest first

    if (error) {
        console.error('Supabase error (fetching comments):', error.message);
        return res.status(500).json({ message: 'Error fetching comments.' });
    }
    
    res.status(200).json(comments || []);
});

// POST: Submit a new comment (will be 'is_approved: false' by default)
// --- REMOVED commentLimiter ---
app.post('/api/comments', async (req, res) => {
    
    const { post_id, name, content } = req.body;

    // 1. Check if fields exist
    if (!post_id || !name || !content) {
        console.error('Validation failed: Missing fields.', req.body);
        return res.status(400).json({ message: 'Missing required fields (post_id, name, content).' });
    }
    
    // 2. Parse/trim them
    const numeric_post_id = parseInt(post_id, 10);
    const trimmedName = name.trim();
    const trimmedContent = content.trim();

    // 3. Check if they are empty *after* trimming
    if (!numeric_post_id || !trimmedName || !trimmedContent) {
        console.error('Validation failed: Fields are empty after trimming.');
        return res.status(400).json({ message: 'All fields must have a value.' });
    }
    
    // 4. Proceed with insert
    // === THIS IS THE FIX: .select() has been removed ===
    const { error } = await supabase
        .from('comments')
        .insert([
            { post_id: numeric_post_id, name: trimmedName, content: trimmedContent }
        ]);
    // === END FIX ===

    if (error) {
        console.error('SupABASE ERROR (inserting comment):', error.message); // <-- More specific log
        console.error('Data sent to Supabase:', { post_id: numeric_post_id, name: trimmedName, content: trimmedContent });
        return res.status(500).json({ message: 'Error posting comment.' });
    }

    console.log('New comment posted, awaiting moderation.');
    res.status(201).json({ message: 'Comment submitted for moderation!' });
});
// === END OF COMMENT ROUTES ===

// === NEW: PUBLIC LIKE ROUTE ===

// POST: Increment the like count for a post
app.post('/api/posts/like/:id', likeLimiter, async (req, res) => {
    const postId = parseInt(req.params.id);

    if (isNaN(postId)) {
        return res.status(400).json({ message: 'Invalid post ID.' });
    }

    // Call the Supabase database function to increment the 'likes' column
    const { error } = await supabase.rpc('increment_likes', { 
        post_id_to_inc: postId 
    });

    if (error) {
        console.error('Supabase error (incrementing like):', error.message);
        return res.status(500).json({ message: 'Error updating like count.' });
    }

    console.log(`Like incremented for post ${postId}`);
    res.status(200).json({ message: 'Like registered!' });
});

// === END OF NEW ROUTE ===


// --- STATIC FILE SERVER (NOW LAST) ---
// This serves all other static files (CSS, JS, images) from the root.
app.use(express.static(path.join(__dirname, '..'), {
    index: false, // We handle the index route ourselves
    setHeaders: (res, filePath) => {
        // Block sensitive files just in case
        if (filePath.endsWith('admin.html') || filePath.endsWith('db.json')) {
            res.status(403).send('Forbidden');
        }
    }
}));

// --- ROOT PAGE ROUTE (CATCH-ALL) ---
// This must be one of the last routes.
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, '..', 'index.html'));
});


// --- Start the Server ---
app.listen(PORT, () => {
    console.log(`--- Blog Server & Admin Panel (Supabase Mode) ---`);
    console.log(`Server running on http://localhost:${PORT}`);
    console.log(`Public Blog: http://localhost:${PORT}`);
    console.log(`Admin Login: http://localhost:${PORT}/admin/login.html`);
    console.log(`-------------------------------------------------`);
});
